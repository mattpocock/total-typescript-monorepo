# What Makes A TypeScript Wizard?

## Knowledge

How things work, understanding the deep parts.

### 1. TSServer

Wizards know how the TSServer works

### 2. Narrowing

Wizards know every narrowing trick in the book. They understand the things TypeScript can't narrow, like `Boolean` and `Map.has`/`Map.get`.

### 3. Mutability

Wizards understand that `let` infers differently from `const`, what `as const` does, and how `readonly` properties don't really work (but `readonly` arrays do!).

### 4. Open vs Closed Objects

Wizards understand that TypeScript has open objects, not closed ones - and how this affects `Object.keys` and excess property checks.

### 5. Assignability

Wizards instinctively know when one type will be assignable to another. They know that `unknown` is the top type, and `never` is the bottom type.

### 6. Strictness

Wizards know how to dial the strictness up and down. They know the pro's and cons of function return types.

### 7. Types and Interfaces

Wizards know that the real decision isn't between types and interfaces, but between interfaces and intersections.

### 8. Deriving vs Declaring

Wizards know the trade-offs between derived types (creating the type based on the shape of another), and redeclaring them. They can make beautiful, self-maintaining types - or they can keep it simple.

### 9. Enums

Wizards know their opinions on enums - one of TypeScript's most controversial features. They know which enums are good, and which are bad.

### 10. Distributivity

Wizards understand how some generic types automatically distribute over unions, and others don't (like `Omit`).

### 11. `infer`

Wizards understand that `infer` is an incredibly narrow feature - but that it does something totally unique.

### 12. The Global Type Scope

Wizards understand the difference beween modules and scripts, and how you can use them to type the global scope.

## Skills

How to actively use TS, use cases.

### 1. IDE Tricks

Wizards know every IDE trick in the book. Autocomplete, refactoring, introspection, JSDoc comments. They fly through their codebases like ninjas.

### 2. Understanding Errors

Wizards read TypeScript errors like it's the Matrix. They know how to fix them, and how to avoid them in the first place.

### 3. Deep-diving `node_modules`

Wizards aren't scared of `node_modules`. They understand declaration files, and how to use go-to-definition to find their way around.

### 4. Developer Pipelines

Wizards know the best way to put TypeScript in the dev pipeline. They understand how to run TS on CI, and how to keep TS out of their way on the dev server.

### 5. `any`

Wizards aren't scared of `any`. They know to avoid it, but also when to judiciously apply it to keep TypeScript quiet.

### 6. Discriminated Unions

Wizards know that discriminated unions let you model complex data structures with ease, from events to Result types and much more.

### 7. Utility Types

Wizards know the right utility type for the right situation. They know the difference between `Omit` vs `Exclude`, and `Extract` vs `Pick`.

### 8. `satisfies` vs `as` vs Variable Annotations

Wizards know the trade-offs between `satisfies`, `as`, and variable annotations. They know which ones are safe, and which are risky.

### 9. Transformations

Wizards know how to transform any type to any other type. They can use mapped types, template literal types, conditional types and more to make powerful type utilities.

### 10. Debugging ESM and CJS

## Results

The problems you'll solve

### 1. NPM Libraries

Wizards know how to publish npm libraries, make beautiful type-safe API's, and abstract away hard problems.

### 2. Unblocking Co-workers

Wizards are the first people pinged on Slack when someone's stuck on a TypeScript problem. They might not even be seniors, but they can unblock anyone.

### 3. Rapid Development

Wizards can build features faster at record speed. TypeScript doesn't slow them down, it speeds them up.

### 4. What Bugs?
