<style>
.shiki {
  --tw-bg-opacity: 1 !important;
  background-color: rgb(17 24 39 / var(--tw-bg-opacity)) !important;
  padding-left: 1.5rem;
  padding-right: 1.5rem;
  padding-top: 1.5rem;
  padding-bottom: 1.5rem;
  font-size: 1rem;
  line-height: 1.5rem;
}

pre {
  overflow-x: auto;
  position: relative;
}

pre.shiki {
  overflow-x: auto;
}

pre.shiki div.dim {
  opacity: 0.5;
}

pre.shiki div.dim,
pre.shiki div.highlight {
  margin: 0;
  padding: 0;
}

pre.shiki div.highlight {
  opacity: 1;
  background-color: #f1f8ff;
}

pre.shiki div.line {
  min-height: 1rem;
}

pre.shiki .language-id {
  display: none;
}

pre .code-container {
  overflow: auto;
}

pre code {
  font-family: 'JetBrains Mono', Menlo, Monaco, Consolas, Courier New, monospace;
  white-space: pre;
  -webkit-overflow-scrolling: touch;
}

pre code a {
  text-decoration: none;
}

pre data-err {
  /* Extracted from VS Code */
  background: url("data:image/svg+xml,%3Csvg%20xmlns%3D'http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg'%20viewBox%3D'0%200%206%203'%20enable-background%3D'new%200%200%206%203'%20height%3D'3'%20width%3D'6'%3E%3Cg%20fill%3D'%23c94824'%3E%3Cpolygon%20points%3D'5.5%2C0%202.5%2C3%201.1%2C3%204.1%2C0'%2F%3E%3Cpolygon%20points%3D'4%2C0%206%2C2%206%2C0.6%205.4%2C0'%2F%3E%3Cpolygon%20points%3D'0%2C2%201%2C3%202.4%2C3%200%2C0.6'%2F%3E%3C%2Fg%3E%3C%2Fsvg%3E")
    repeat-x bottom left;
  padding-bottom: 3px;
}

pre .query {
  margin-bottom: 10px;
  color: #137998;
  display: inline-block;
}

pre .error,
pre .error-behind {
  margin-left: -14px;
  margin-top: 8px;
  margin-bottom: 4px;
  padding: 6px;
  padding-left: 14px;
  padding-right: 14px;
  white-space: pre-wrap;
  display: block;
  max-width: 42rem;
  font-size: 0.875rem;
  line-height: 1.25rem;
}

pre .error {
  --tw-bg-opacity: 1;
  background-color: rgb(31 41 55 / var(--tw-bg-opacity));
  --tw-text-opacity: 1;
  color: rgb(254 242 242 / var(--tw-text-opacity));
  position: absolute;
  border-left: 4px solid #bf1818;
  /* Give the space to the error code */
  display: flex;
  align-items: center;
}

pre .error .code {
  display: none;
}

pre .error-behind {
  -webkit-user-select: none;
     -moz-user-select: none;
          user-select: none;
  visibility: transparent;
  color: transparent;
}

/* Queries */

pre .arrow {
  /* Transparent background */
  --tw-bg-opacity: 1;
  background-color: rgb(31 41 55 / var(--tw-bg-opacity));
  position: relative;
  top: -7px;
  margin-left: 0.1rem;
  /* Edges */
  border-left: 1px solid rgb(51, 65, 85);
  border-top: 1px solid rgb(51, 65, 85);
  transform: translateY(25%) rotate(45deg);
  /* Size */
  height: 8px;
  width: 8px;
}

pre .popover {
  --tw-bg-opacity: 1;
  background-color: rgb(31 41 55 / var(--tw-bg-opacity));
  --tw-text-opacity: 1;
  color: rgb(243 244 246 / var(--tw-text-opacity));
  margin-bottom: 10px;
  display: inline-block;
  padding: 0 0.5rem 0.3rem;
  margin-top: 10px;
  border-radius: 3px;
  max-width: 42rem;
  font-size: 0.875rem;
  line-height: 1.25rem;
}

/* Completion */

pre .inline-completions ul.dropdown {
  display: inline-block;
  position: absolute;
  width: 240px;
  background-color: gainsboro;
  color: grey;
  padding-top: 4px;
  font-family: var(--code-font);
  font-size: 0.8rem;
  margin: 0;
  padding: 0;
  border-left: 4px solid #4b9edd;
}

pre .inline-completions ul.dropdown::before {
  background-color: #4b9edd;
  width: 2px;
  position: absolute;
  top: -1.2rem;
  left: -3px;
  content: ' ';
}

pre .inline-completions ul.dropdown li {
  overflow-x: hidden;
  padding-left: 4px;
  margin-bottom: 4px;
}

pre .inline-completions ul.dropdown li.deprecated {
  text-decoration: line-through;
}

pre .inline-completions ul.dropdown li span.result-found {
  color: #4b9edd;
}

pre .inline-completions ul.dropdown li span.result {
  width: 100px;
  color: black;
  display: inline-block;
}

.dark-theme .markdown pre {
  background-color: #d8d8d8;
  border-color: #ddd;
  filter: invert(98%) hue-rotate(180deg);
}

data-lsp {
  /* Fades in unobtrusively */
  transition-timing-function: ease;
  transition: border-color 0.3s;
}

/** Annotations support, providing a tool for meta commentary */

.tag-container {
  position: relative;
}

.tag-container .twoslash-annotation {
  position: absolute;
  font-family: 'JetBrains Mono', Menlo, Monaco, Consolas, Courier New, monospace;
  right: -10px;
  /** Default annotation text to 200px */
  width: 200px;
  color: #187abf;
  background-color: #fcf3d9 bb;
}

.tag-container .twoslash-annotation p {
  text-align: left;
  font-size: 0.8rem;
  line-height: 0.9rem;
}

.tag-container .twoslash-annotation svg {
  float: left;
  margin-left: -44px;
}

.tag-container .twoslash-annotation.left {
  right: auto;
  left: -200px;
}

.tag-container .twoslash-annotation.left svg {
  float: right;
  margin-right: -5px;
}

/** Support for showing console log/warn/errors inline */

pre .logger {
  display: flex;
  align-items: center;
  color: black;
  padding: 6px;
  padding-left: 8px;
  width: calc(100% - 19px);
  white-space: pre-wrap;
}

pre .logger svg {
  margin-right: 9px;
}

pre .logger.error-log {
  --tw-bg-opacity: 1;
  background-color: rgb(31 41 55 / var(--tw-bg-opacity));
  border-left: 4px solid #bf1818;
}

pre .logger.warn-log {
  background-color: #ffe;
  border-left: 4px solid #eae662;
}

pre .logger.log-log {
  background-color: #e9e9e9;
  border-left: 4px solid #ababab;
}

pre .logger.log-log svg {
  margin-left: 6px;
  margin-right: 9px;
}
</style>
<h1>There is no such thing as a generic</h1>
<p>I want to start this course with an idea that will change the way you think about generics.</p>
<p>There is no such thing as a 'generic'.</p>
<p>There are <strong>generic types</strong>, <strong>generic functions</strong>, and <strong>generic classes</strong>.</p>
<p>There are <strong>type arguments</strong> and <strong>type parameters</strong>.</p>
<p>You cannot 'pass' a generic, 'declare' it, or 'infer' it.</p>
<p>In other words, 'generic' is not a noun, it's an adjective.</p>
<h2>"A generic"</h2>
<p>People think of 'a generic' as <em>something</em> in TypeScript.</p>
<p>You might look at the code below and say 'we're passing a generic to useState'.</p>
<pre class="shiki dark-plus twoslash lsp not-prose" style="background-color:#1E1E1E;color:#D4D4D4" tabindex="0"><code><span class="line"><span style="color:#C586C0">import</span><span style="color:#D4D4D4"> { </span><span style="color:#9CDCFE"><data-lsp lsp="(alias) function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>] (+1 overload)
import useState">useState</data-lsp></span><span style="color:#D4D4D4"> } </span><span style="color:#C586C0">from</span><span style="color:#CE9178"> "react"</span><span style="color:#D4D4D4">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCDCAA"><data-lsp lsp="(alias) useState<string>(): [string | undefined, React.Dispatch<React.SetStateAction<string | undefined>>] (+1 overload)
import useState">useState</data-lsp></span><span style="color:#D4D4D4">&#x3C;</span><span style="color:#4EC9B0">string</span><span style="color:#D4D4D4">>();</span></span>
<span class="line"></span></code></pre>
<p>You might also say 'we're passing two generics to <code>Record</code>':</p>
<pre class="shiki dark-plus twoslash lsp not-prose" style="background-color:#1E1E1E;color:#D4D4D4" tabindex="0"><code><span class="line"><span style="color:#569CD6">type</span><span style="color:#4EC9B0"> </span><span style="color:#4EC9B0"><data-lsp lsp="type NumberRecord = {
    [x: string]: number;
}">NumberRecord</data-lsp></span><span style="color:#D4D4D4"> = </span><span style="color:#4EC9B0"><data-lsp lsp="type Record<K extends string | number | symbol, T> = { [P in K]: T; }">Record</data-lsp></span><span style="color:#D4D4D4">&#x3C;</span><span style="color:#4EC9B0">string</span><span style="color:#D4D4D4">, </span><span style="color:#4EC9B0">number</span><span style="color:#D4D4D4">>;</span></span>
<span class="line"></span></code></pre>
<p>How about '<code>Maybe</code> has two generics'?</p>
<pre class="shiki dark-plus twoslash lsp not-prose" style="background-color:#1E1E1E;color:#D4D4D4" tabindex="0"><code><span class="line"><span style="color:#569CD6">type</span><span style="color:#4EC9B0"> </span><span style="color:#4EC9B0"><data-lsp lsp="type Maybe<T> = T | null | undefined">Maybe</data-lsp></span><span style="color:#D4D4D4">&#x3C;</span><span style="color:#4EC9B0"><data-lsp lsp="(type parameter) T in type Maybe<T>">T</data-lsp></span><span style="color:#D4D4D4">> = </span><span style="color:#4EC9B0"><data-lsp lsp="(type parameter) T in type Maybe<T>">T</data-lsp></span><span style="color:#D4D4D4"> | </span><span style="color:#4EC9B0">null</span><span style="color:#D4D4D4"> | </span><span style="color:#4EC9B0">undefined</span><span style="color:#D4D4D4">;</span></span>
<span class="line"><span style="color:#6A9955">//         ^ Generic</span></span>
<span class="line"></span></code></pre>
<p>People look at the angle bracket syntax and think 'that's a generic'. But because generics can appear on functions, function calls, types, and type declarations, it's not clear what 'a generic' even is.</p>
<p>That's why it's such a hard concept for folks to grasp - the word is too overloaded.</p>
<p>So, what terms should we use instead?</p>
<h2>Type Arguments</h2>
<p>How would we describe this code if we couldn't use the word 'generic'?</p>
<pre class="shiki dark-plus twoslash lsp not-prose" style="background-color:#1E1E1E;color:#D4D4D4" tabindex="0"><code><span class="line"><span style="color:#C586C0">import</span><span style="color:#D4D4D4"> { </span><span style="color:#9CDCFE"><data-lsp lsp="(alias) function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>] (+1 overload)
import useState">useState</data-lsp></span><span style="color:#D4D4D4"> } </span><span style="color:#C586C0">from</span><span style="color:#CE9178"> "react"</span><span style="color:#D4D4D4">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCDCAA"><data-lsp lsp="(alias) useState<string>(): [string | undefined, React.Dispatch<React.SetStateAction<string | undefined>>] (+1 overload)
import useState">useState</data-lsp></span><span style="color:#D4D4D4">&#x3C;</span><span style="color:#4EC9B0">string</span><span style="color:#D4D4D4">>();</span></span>
<span class="line"></span></code></pre>
<p>We're not passing a 'generic' to <code>useState</code>. We are passing it a <strong>type argument</strong>. And the <strong>type argument</strong> we're passing is <code>string</code>.</p>
<p>How about <code>Record</code>?</p>
<pre class="shiki dark-plus twoslash lsp not-prose" style="background-color:#1E1E1E;color:#D4D4D4" tabindex="0"><code><span class="line"><span style="color:#569CD6">type</span><span style="color:#4EC9B0"> </span><span style="color:#4EC9B0"><data-lsp lsp="type NumberRecord = {
    [x: string]: number;
}">NumberRecord</data-lsp></span><span style="color:#D4D4D4"> = </span><span style="color:#4EC9B0"><data-lsp lsp="type Record<K extends string | number | symbol, T> = { [P in K]: T; }">Record</data-lsp></span><span style="color:#D4D4D4">&#x3C;</span><span style="color:#4EC9B0">string</span><span style="color:#D4D4D4">, </span><span style="color:#4EC9B0">number</span><span style="color:#D4D4D4">>;</span></span>
<span class="line"></span></code></pre>
<p>We're passing two <strong>type arguments</strong> to <code>Record</code>. The first <strong>type argument</strong> is <code>string</code>, and the second <strong>type argument</strong> is <code>number</code>.</p>
<p>So - a type argument works just like a function argument. We can pass it to a function, class, or type.</p>
<p>But not all types, functions, and classes can receive type arguments:</p>
<pre class="shiki dark-plus twoslash lsp not-prose" style="background-color:#1E1E1E;color:#D4D4D4" tabindex="0"><code><span class="line"><span style="color:#569CD6">type</span><span style="color:#4EC9B0"> </span><span style="color:#4EC9B0"><data-lsp lsp="type Example = any">Example</data-lsp></span><span style="color:#D4D4D4"> = </span><span style="color:#4EC9B0"><data-err>PropertyKey</data-err></span><span style="color:#D4D4D4"><data-err>&#x3C;</data-err></span><span style="color:#4EC9B0"><data-err>string</data-err></span><span style="color:#D4D4D4"><data-err>></data-err></span><span style="color:#D4D4D4">;</span></span><div class="error"><span>Type 'PropertyKey' is not generic.</span><span class="code">2315</span></div><span class="error-behind">Type 'PropertyKey' is not generic.</span><span class="line"></span>
<span class="line"><span style="color:#DCDCAA"><data-lsp lsp="function encodeURIComponent(uriComponent: string | number | boolean): string">encodeURIComponent</data-lsp></span><span style="color:#D4D4D4">&#x3C;</span><span style="color:#4EC9B0"><data-err>string</data-err></span><span style="color:#D4D4D4">>();</span></span><div class="error"><span>Expected 0 type arguments, but got 1.</span><span class="code">2558</span></div><span class="error-behind">Expected 0 type arguments, but got 1.</span><span class="line"></span>
<span class="line"><span style="color:#569CD6">new</span><span style="color:#DCDCAA"> </span><span style="color:#DCDCAA"><data-lsp lsp="var Event: new (type: string, eventInitDict?: EventInit | undefined) => Event">Event</data-lsp></span><span style="color:#D4D4D4">&#x3C;</span><span style="color:#4EC9B0"><data-err>string</data-err></span><span style="color:#D4D4D4">>();</span></span><div class="error"><span>Expected 0 type arguments, but got 1.</span><span class="code">2558</span></div><span class="error-behind">Expected 0 type arguments, but got 1.</span><span class="line"></span></code></pre>
<p>So how do we know which ones can receive them?</p>
<p>You have generic types:</p>
<pre class="shiki dark-plus twoslash lsp not-prose" style="background-color:#1E1E1E;color:#D4D4D4" tabindex="0"><code><span class="line"><span style="color:#6A9955">// Generic Type</span></span>
<span class="line"><span style="color:#569CD6">type</span><span style="color:#4EC9B0"> </span><span style="color:#4EC9B0"><data-lsp lsp="type Maybe<T> = T | null | undefined">Maybe</data-lsp></span><span style="color:#D4D4D4">&#x3C;</span><span style="color:#4EC9B0"><data-lsp lsp="(type parameter) T in type Maybe<T>">T</data-lsp></span><span style="color:#D4D4D4">> = </span><span style="color:#4EC9B0"><data-lsp lsp="(type parameter) T in type Maybe<T>">T</data-lsp></span><span style="color:#D4D4D4"> | </span><span style="color:#4EC9B0">undefined</span><span style="color:#D4D4D4"> | </span><span style="color:#4EC9B0">null</span><span style="color:#D4D4D4">;</span></span>
<span class="line"><span style="color:#6A9955">//         ^ Type Parameter</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6">type</span><span style="color:#4EC9B0"> </span><span style="color:#4EC9B0"><data-lsp lsp="type MaybeString = string | null | undefined">MaybeString</data-lsp></span><span style="color:#D4D4D4"> = </span><span style="color:#4EC9B0"><data-lsp lsp="type Maybe<T> = T | null | undefined">Maybe</data-lsp></span><span style="color:#D4D4D4">&#x3C;</span><span style="color:#4EC9B0">string</span><span style="color:#D4D4D4">>;</span></span>
<span class="line"></span></code></pre>
<p>And generic functions.</p>
<pre class="shiki dark-plus twoslash lsp not-prose" style="background-color:#1E1E1E;color:#D4D4D4" tabindex="0"><code><span class="line"><span style="color:#6A9955">// Generic Function</span></span>
<span class="line"><span style="color:#569CD6">const</span><span style="color:#DCDCAA"> </span><span style="color:#DCDCAA"><data-lsp lsp="const uniqueArray: <T>(array: T[]) => T[]">uniqueArray</data-lsp></span><span style="color:#D4D4D4"> = &#x3C;</span><span style="color:#4EC9B0"><data-lsp lsp="(type parameter) T in <T>(array: T[]): T[]">T</data-lsp></span><span style="color:#D4D4D4">>(</span><span style="color:#9CDCFE"><data-lsp lsp="(parameter) array: T[]">array</data-lsp></span><span style="color:#D4D4D4">: </span><span style="color:#4EC9B0"><data-lsp lsp="(type parameter) T in <T>(array: T[]): T[]">T</data-lsp></span><span style="color:#D4D4D4">[]) </span><span style="color:#569CD6">=></span><span style="color:#D4D4D4"> {</span></span>
<span class="line"><span style="color:#6A9955">  //                 ^ Type Parameter</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C586C0">  return</span><span style="color:#9CDCFE"> </span><span style="color:#9CDCFE"><data-lsp lsp="var Array: ArrayConstructor">Array</data-lsp></span><span style="color:#D4D4D4">.</span><span style="color:#DCDCAA"><data-lsp lsp="(method) ArrayConstructor.from<T>(iterable: Iterable<T> | ArrayLike<T>): T[] (+3 overloads)">from</data-lsp></span><span style="color:#D4D4D4">(</span><span style="color:#569CD6">new</span><span style="color:#DCDCAA"> </span><span style="color:#DCDCAA"><data-lsp lsp="var Set: SetConstructor
new <T>(iterable?: Iterable<T> | null | undefined) => Set<T> (+1 overload)">Set</data-lsp></span><span style="color:#D4D4D4">(</span><span style="color:#9CDCFE"><data-lsp lsp="(parameter) array: T[]">array</data-lsp></span><span style="color:#D4D4D4">));</span></span>
<span class="line"><span style="color:#D4D4D4">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6">const</span><span style="color:#4FC1FF"> </span><span style="color:#4FC1FF"><data-lsp lsp="const uniqueStrings: string[]">uniqueStrings</data-lsp></span><span style="color:#D4D4D4"> = </span><span style="color:#DCDCAA"><data-lsp lsp="const uniqueArray: <string>(array: string[]) => string[]">uniqueArray</data-lsp></span><span style="color:#D4D4D4">&#x3C;</span><span style="color:#4EC9B0">string</span><span style="color:#D4D4D4">>([</span><span style="color:#CE9178">"a"</span><span style="color:#D4D4D4">, </span><span style="color:#CE9178">"b"</span><span style="color:#D4D4D4">, </span><span style="color:#CE9178">"a"</span><span style="color:#D4D4D4">]);</span></span>
<span class="line"></span></code></pre>
<h2>Type Parameters</h2>
<p>Let's look at our <code>Maybe&#x3C;T></code> from earlier.</p>
<pre class="shiki dark-plus twoslash lsp not-prose" style="background-color:#1E1E1E;color:#D4D4D4" tabindex="0"><code><span class="line"><span style="color:#569CD6">type</span><span style="color:#4EC9B0"> </span><span style="color:#4EC9B0"><data-lsp lsp="type Maybe<T> = T | null | undefined">Maybe</data-lsp></span><span style="color:#D4D4D4">&#x3C;</span><span style="color:#4EC9B0"><data-lsp lsp="(type parameter) T in type Maybe<T>">T</data-lsp></span><span style="color:#D4D4D4">> = </span><span style="color:#4EC9B0"><data-lsp lsp="(type parameter) T in type Maybe<T>">T</data-lsp></span><span style="color:#D4D4D4"> | </span><span style="color:#4EC9B0">null</span><span style="color:#D4D4D4"> | </span><span style="color:#4EC9B0">undefined</span><span style="color:#D4D4D4">;</span></span>
<span class="line"></span></code></pre>
<p>Here, <code>Maybe</code> is declaring a <strong>type parameter</strong>. The <strong>type parameter</strong> is <code>T</code>.</p>
<p>This means that <code>Maybe</code> MUST be passed a type argument. If we don't pass it a type argument, we get an error:</p>
<pre class="shiki dark-plus twoslash lsp not-prose" style="background-color:#1E1E1E;color:#D4D4D4" tabindex="0"><code><span class="line"></span>
<span class="line"><span style="color:#569CD6">type</span><span style="color:#4EC9B0"> </span><span style="color:#4EC9B0"><data-lsp lsp="type Example = any">Example</data-lsp></span><span style="color:#D4D4D4"> = </span><span style="color:#4EC9B0"><data-err>Maybe</data-err></span><span style="color:#D4D4D4">;</span></span><div class="error"><span>Generic type 'Maybe' requires 1 type argument(s).</span><span class="code">2314</span></div><span class="error-behind">Generic type 'Maybe' requires 1 type argument(s).</span><span class="line"></span></code></pre>
<p>So, a <strong>type parameter</strong> is like a function parameter. It declares that you can pass a type argument to the type, function, or class.</p>
<h2>Generic Types</h2>
<p>Let's bring the phrase 'generic' back into our vocabulary and give it a proper definition.</p>
<blockquote>
<p><strong>generic</strong> - <em>adj</em>: a type, function, or class that declares one or more type parameters.</p>
</blockquote>
<p>So, <code>Maybe</code> is a generic type because it declares a type parameter.</p>
<p>And <code>PropertyKey</code>, which we saw earlier, is NOT generic. Even the error says so.</p>
<pre class="shiki dark-plus twoslash lsp not-prose" style="background-color:#1E1E1E;color:#D4D4D4" tabindex="0"><code><span class="line"><span style="color:#569CD6">type</span><span style="color:#4EC9B0"> </span><span style="color:#4EC9B0"><data-lsp lsp="type Example = any">Example</data-lsp></span><span style="color:#D4D4D4"> = </span><span style="color:#4EC9B0"><data-err>PropertyKey</data-err></span><span style="color:#D4D4D4"><data-err>&#x3C;</data-err></span><span style="color:#4EC9B0"><data-err>string</data-err></span><span style="color:#D4D4D4"><data-err>></data-err></span><span style="color:#D4D4D4">;</span></span><div class="error"><span>Type 'PropertyKey' is not generic.</span><span class="code">2315</span></div><span class="error-behind">Type 'PropertyKey' is not generic.</span><span class="line"></span></code></pre>
<p>So, generic types are simply types that declare type parameters.</p>
<h2>Generic Functions and Generic Classes</h2>
<p>Functions and classes can also declare type parameters. When they do, they become generic functions and generic classes and can receive type arguments.</p>
<pre class="shiki dark-plus twoslash lsp not-prose" style="background-color:#1E1E1E;color:#D4D4D4" tabindex="0"><code><span class="line"><span style="color:#569CD6">const</span><span style="color:#DCDCAA"> </span><span style="color:#DCDCAA"><data-lsp lsp="const myFunc: <T>() => void">myFunc</data-lsp></span><span style="color:#D4D4D4"> = &#x3C;</span><span style="color:#4EC9B0"><data-lsp lsp="(type parameter) T in <T>(): void">T</data-lsp></span><span style="color:#D4D4D4">>() </span><span style="color:#569CD6">=></span><span style="color:#D4D4D4"> {</span></span>
<span class="line"><span style="color:#6A9955">  //            ^ Type Parameter</span></span>
<span class="line"><span style="color:#D4D4D4">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#DCDCAA"><data-lsp lsp="const myFunc: <string>() => void">myFunc</data-lsp></span><span style="color:#D4D4D4">&#x3C;</span><span style="color:#4EC9B0">string</span><span style="color:#D4D4D4">>();</span></span>
<span class="line"></span></code></pre>
<pre class="shiki dark-plus twoslash lsp not-prose" style="background-color:#1E1E1E;color:#D4D4D4" tabindex="0"><code><span class="line"><span style="color:#569CD6">class</span><span style="color:#4EC9B0"> </span><span style="color:#4EC9B0"><data-lsp lsp="class MyClass<T>">MyClass</data-lsp></span><span style="color:#D4D4D4">&#x3C;</span><span style="color:#4EC9B0"><data-lsp lsp="(type parameter) T in MyClass<T>">T</data-lsp></span><span style="color:#D4D4D4">> {</span></span>
<span class="line"><span style="color:#6A9955">  //          ^ Type Parameter</span></span>
<span class="line"><span style="color:#6A9955">  // implementation...</span></span>
<span class="line"><span style="color:#D4D4D4">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6">new</span><span style="color:#DCDCAA"> </span><span style="color:#DCDCAA"><data-lsp lsp="constructor MyClass<string>(): MyClass<string>">MyClass</data-lsp></span><span style="color:#D4D4D4">&#x3C;</span><span style="color:#4EC9B0">string</span><span style="color:#D4D4D4">>();</span></span>
<span class="line"></span></code></pre>
<p>This can be used in all sorts of ways. By far the most popular is to provide type information to third-party libraries. In the example below, how would <code>useState</code> know what type it's supposed to be returning?</p>
<pre class="shiki dark-plus twoslash lsp not-prose" style="background-color:#1E1E1E;color:#D4D4D4" tabindex="0"><code><span class="line"><span style="color:#C586C0">import</span><span style="color:#D4D4D4"> { </span><span style="color:#9CDCFE"><data-lsp lsp="(alias) function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>] (+1 overload)
import useState">useState</data-lsp></span><span style="color:#D4D4D4"> } </span><span style="color:#C586C0">from</span><span style="color:#CE9178"> "react"</span><span style="color:#D4D4D4">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#569CD6">const</span><span style="color:#D4D4D4"> [</span><span style="color:#4FC1FF"><data-lsp lsp="const message: undefined">message</data-lsp></span><span style="color:#D4D4D4">, </span><span style="color:#4FC1FF"><data-lsp lsp="const setMessage: React.Dispatch<React.SetStateAction<undefined>>">setMessage</data-lsp></span><span style="color:#D4D4D4">] = </span><span style="color:#DCDCAA"><data-lsp lsp="(alias) useState<undefined>(): [undefined, React.Dispatch<React.SetStateAction<undefined>>] (+1 overload)
import useState">useState</data-lsp></span><span style="color:#D4D4D4">(); </span><span style="color:#6A9955">// message is undefined</span></span>
<span class="line"></span></code></pre>
<p>It can't - so we have to pass a type argument to it.</p>
<pre class="shiki dark-plus twoslash lsp not-prose" style="background-color:#1E1E1E;color:#D4D4D4" tabindex="0"><code><span class="line"><span style="color:#C586C0">import</span><span style="color:#D4D4D4"> { </span><span style="color:#9CDCFE"><data-lsp lsp="(alias) function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>] (+1 overload)
import useState">useState</data-lsp></span><span style="color:#D4D4D4"> } </span><span style="color:#C586C0">from</span><span style="color:#CE9178"> "react"</span><span style="color:#D4D4D4">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A9955">// message is string | undefined</span></span>
<span class="line"><span style="color:#569CD6">const</span><span style="color:#D4D4D4"> [</span><span style="color:#4FC1FF"><data-lsp lsp="const message: string | undefined">message</data-lsp></span><span style="color:#D4D4D4">, </span><span style="color:#4FC1FF"><data-lsp lsp="const setMessage: React.Dispatch<React.SetStateAction<string | undefined>>">setMessage</data-lsp></span><span style="color:#D4D4D4">] = </span><span style="color:#DCDCAA"><data-lsp lsp="(alias) useState<string>(): [string | undefined, React.Dispatch<React.SetStateAction<string | undefined>>] (+1 overload)
import useState">useState</data-lsp></span><span style="color:#D4D4D4">&#x3C;</span><span style="color:#4EC9B0">string</span><span style="color:#D4D4D4">>();</span></span>
<span class="line"></span></code></pre>
<h2>Why This Matters</h2>
<p>The term "generic" has become far too overloaded. When we mix up type arguments and parameters with generic functions and types, it's hard to understand what's going on.</p>
<p>For me, learning generics really clicked when I understood that these concepts are separate:</p>
<p>| Concept          | Example                                            |
| ---------------- | -------------------------------------------------- |
| Generic Type     | <code>type MyType&#x3C;T> = T</code>                               |
| Generic Function | <code>const myFunc = &#x3C;T>() => {}</code>                       |
| Type Parameter   | <code>T</code> in <code>MyType&#x3C;T></code> or <code>myFunc&#x3C;T></code>                  |
| Type Argument    | <code>string</code> in <code>MyType&#x3C;string></code> or <code>myFunc&#x3C;string>()</code> |</p>
<p>In this course, I'll be taking you through each of these ideas in turn. We'll start with how to use generic types to DRY up your type code. Then, we'll head to generic functions and classes.</p>
<p>By the end of this course, I guarantee you'll understand generics at a much deeper level. You'll know when to use them, and what to use them for.</p>
<p>Want to get the next lesson now? Click the link below.</p>